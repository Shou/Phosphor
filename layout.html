<script>

var qsa = Document.prototype.querySelectorAll.bind(document)

function viewFormat(s) {
    var fs = ["", "k", "m", "b"]

    var ss = s.split("<br>")
    var cs = ss[0].split(/,/g)
    var v = cs[0].trim() + fs[cs.length - 1]
    var w = ss[1] ? "\n\uf007 " + ss[1].split(' ')[0] : ""

    return v + w
}

function views(vs) {
    for (var i = 0, l = vs.length; i < l; i++) {
        vs[i].dataset.desc = vs[i].innerHTML.split("<br>")[0].trim()
        vs[i].textContent = viewFormat(vs[i].innerHTML)
    }
}

function tf() {
  time += 100

  var vs = qsa(".c_cat-replies > a, .c_cat-views")
  if (vs.length > 0) {
    views(vs)
    mo.observe($("#inlinetopic")[0], { childList: true })

  } else if (time < maxTime)
    tu = setTimeout(tf, 100)
}

// TODO use MutationObserver on the body instead of a setTimeout loop
// this is super dumb but let's pretend it's not
var maxTime = 1000
var time = 0
var tu = setTimeout(tf, 100)

var mo = new MutationObserver(function(ms) {
  ms.forEach(function(m) {
    var vs = qsa(".c_cat-replies > a, .c_cat-views")
    views(vs)
  })
})

</script>

<div id="realtop">
<!-- HEADER -->
<input id="toggle-topmenu" type="checkbox">
<label for="toggle-topmenu"><div></div></label>
<!-- TOPMENU -->
</div>

<script>

var ns = $( "#menu_rcp > a > strong > small"
          + ", #menu_pm > a > strong > small")
  , topBar = $("#toggle-topmenu + label")[0]

for (var i = 0, l = ns.length; i < l; i++)
    if (parseInt(ns[i].textContent) > 0)
        topBar.classList.add("glow")

</script>

<div id="subhuman">
<!-- NAV -->
<input id="toggle-submenu" type="checkbox">
<label for="toggle-submenu"><div></div></label>
<!-- SUBMENU -->
</div>

<div id="wrap">
<!-- BOARD -->
</div>

<script>

var ls = localStorage
var DRAFTKEY = "drafts"

// Thread ID; is nullable
var tid = $("[name=t]").attr("value")
// preview XHR limit timeout
var pretimeout = null
// preview element
var preve = null
// textarea element
var texte = $("#c_post-text")[0]
         || $("#fast-reply > dd > textarea")[0]
         || $("#quickcompose")[0]
// relevant textarea container element
var parnt = $("#c_post")[0] || $("#fast-reply")[0]
// quick-reply form
var qrform = $("form[action$='/post/']")


function id(x) { return x }


function jsonRead(k, a) {
  try {
    return JSON.parse(localStorage[k])

  } catch (e) {
    return a
  }
}

function jsonWrite(k, x) {
  localStorage[k] = JSON.stringify(x)
}

// | XXX probably really slow
// draftRead :: String -> a -> Either a String
function draftRead(k, a) {
  if (! k) return a

  var ds = jsonRead(DRAFTKEY, {})

  // Months approximation
  var date = Math.floor(Date.now() / 1000 / 3600 / 24 / 30)
  // Delete drafts older than a month
  for (kt in ds) if (date - ds[kt].date > 1) {
    delete ds[kt]
    jsonWrite(DRAFTKEY, ds)
    break
  }

  if (k in ds) {
    ds[k].date = date
    // save access date
    jsonWrite(DRAFTKEY, ds)
    return ds[k].text

  } else return a
}

function draftWrite(k, a) {
  if (! k) return

  var ds = jsonRead(DRAFTKEY, {})

  // Months approximation
  var date = Math.floor(Date.now() / 1000 / 3600 / 24 / 30)
  // Delete drafts older than a month
  for (kt in ds) if (date - ds[kt].date > 1) {
    delete ds[kt]
    break
  }

  var o = { date: date, text: a }
  jsonWrite(DRAFTKEY, (a ? ds[k] = o : delete ds[k], ds))
}

// saveDraft :: IO ()
function saveDraft() {
  draftWrite(tid, this.value)
}

// quotePyramid :: Elem -> IO ()
function quotePyramid(s) {
    var qdls = document.querySelectorAll(".c_post > blockquote > div > blockquote > dl")
    for (var i = 0, l = qdls.length; i < l; i++)
        qdls[i].addEventListener("click", toggleQuote)
}

// toggleQuote :: Event -> IO ()
function toggleQuote(e) {
    var e = this.nextElementSibling
    e.style.display = e.style.display !== "block" ? "block" : "none"
}

// TODO multiquotes
function loadQuotes(pid) {
  var pids = $.zb.get_cache_session("multiquote" + tid).split('|').filter(id)
    , fid = $("[name=f]").attr("value")

  console.log(pids)
  if (pids.indexOf(pid) === -1) pids.push(pid)

  var url = $.zb.stat.url + "post/?mode=2&type=4&f=" + fid + "&t=" + tid
          + "&multiquote_arr=" + pids.join('|')

  $.get(url, "", function(data) {
    var quotesText = $(data).find("#c_post-text").attr("value")
    texte.value += quotesText
    makePreview()
  })
}

// TODO requestAnimationFrame
// makePreview :: IO ()
function makePreview() {
  if (pretimeout === null)
    pretimeout = setTimeout(function() {
      pretimeout = null

      var q = $("#txt_quote")[0]
        , t = (q ? "[quote]" + q.value + "[/quote]" : "") + texte.value

      preview(t, function(data) {
        if (preve === null) {
          preve = document.createElement("div")
          preve.id = "c_post-preview"
          preve.innerHTML = data

          $(parnt).append(preve)

        } else preve.innerHTML = data
      })

      try {
      scrollEquilibrate(preve, texte)
      } catch (e) { console.log("scrollEquilibrate " + e.toString()) }
    }, 250)
}

// preview :: String -> (XHR -> IO ()) -> IO ()
function preview(p, f) {
  var fd = new FormData()
  fd.append("task", '5')
  fd.append("post", p)

  var x = new XMLHttpRequest()
  x.addEventListener("load", function() { f(this.responseText) })
  x.open("POST", '/' + location.pathname.split('/')[1] + "/tasks/", true)
  x.send(fd)

  return x
}

// TODO use textarea caret position if no scrollbar
// get total height of e1's nodes, treat non-text as one line.
// the old algorithm should become much more precise
// scrollEquilibrate :: Elem -> Elem -> IO ()
function scrollEquilibrate(e0, e1) {
  var h = 0
  // Coordinates to skip
  var holes = []
  var skips = ["IMG", "OBJECT", "IFRAME", "BLOCKQUOTE"]

  for (var i = 0, ns = e0.childNodes, l = ns.length; i < l; i++) {
    if (ns[i].nodeType === document.TEXT_NODE) h += textHeight(ns[i])

    else {
      // check if image, object, so forth, mark current height
      // then skip those coordinates
      if (skips.indexOf(ns[i].tagName) !== -1) {
        holes.push([h, h + ns[i].clientHeight])
        h += ns[i].clientHeight

        //var fs = parseFloat(window.getComputedStyle(ns[i]).fontSize)
        //var lh = parseFloat(window.getComputedStyle(ns[i]).lineHeight)
        //h += fs * ((lh - 1) / 2 + 1)
      }
    }
  }

  // TODO Edge attraction
  //var offset = Math.round(Math.cos(Math.PI * e1.scrollTop / (e1.scrollHeight - e1.clientHeight)) * 5) * -1 * 7
  var m = e1.scrollHeight - e1.clientHeight
    , x = e1.scrollTop
    , t = 10
  var offset = Math.trunc(Math.cos(Math.PI / m * x) * -1 * (1 + t / m / (m / 100))) * t
  // Amount to scroll
  // TODO FIXME account for image holes and actually use `h`?
  var scroll = (e1.scrollTop + offset) * ((e0.scrollHeight - e0.clientHeight) / (e1.scrollHeight - e1.clientHeight))

  // Use caret position instead; there is no scrollbar for e1
  if (e1.scrollHeight <= e1.clientHeight) {
    var acc = -1
    var lines = e1.value.split('\n')

    for (var i = 0, l = lines.length; i < l; i++) {
        acc += lines[i].length + 1
        if (e1.selectionStart <= acc) {
          scroll = i / l * (e0.scrollHeight - e0.clientHeight)
          break
        }
    }

    console.log("Line: " + i + "; Scroll: " + scroll)
  }

  // FIXME not working?
  // Hole-skipping loop
  console.log(holes.map(function(xs) {
    return Math.floor(xs[0]) + " - " + Math.floor(xs[1])
  }))
  var b = false
  for (var i = 0, l = holes.length; i < l; i++) {
    // within hole's precinct
    if (holes[i][0] < scroll && holes[i][1] > scroll) {
      console.log(holes[i][0] + " < " + scroll + " < " + holes[i][1])
      // skip to hole's lower edge
      scroll = holes[i][1]
      console.log("new " + scroll)

      // we only need to match one hole per scroll
      break
    }
  }

  e0.scrollTop = scroll
}

// textHeight :: TextNode -> Int
function textHeight(tn) {
  var r = document.createRange()
  r.selectNodeContents(tn)
  var rect = r.getBoundingClientRect()
  return rect.bottom - rect.top
}

// | Close [parent] button
var cb = $("<input>", { type: "button"
                      , value: "x"
                      , class: "close-button" 
                      }).bind("click", function(e) {
                          // Hide button
                          this.parentNode.classList.remove("show-bottom")
                          // Delete draft and clear
                          draftWrite(tid, null)
                          texte.value = ""
                          preve.innerHTML = ""
                      })

function main() {
  quotePyramid()

  // Scroll sync event
  $(texte).bind("scroll keyup", function(e) {
    scrollEquilibrate(preve, texte)
  })

  // Auto-preview event
  $(texte).bind("input focusout", makePreview)

  // Draft saving event
  $(texte).bind("input focusout", saveDraft)

  // Quick Reply spawn event
  $(".topic-buttons").bind("click", function(e) {
    if (e.button === 0) {
      e.preventDefault()
      $("#fast-reply")[0].classList.add("show-bottom")
    }
  })

  // Quick Reply quote event
  $(".right > [href*='mode=2']").off("click").bind("click", function(e) {
    if (e.button === 0) {
      e.preventDefault()
      loadQuotes(this.href.match(/&p=(\d+)/)[1])
      $("#fast-reply")[0].classList.add("show-bottom")
    }
  })

  // XXX this may lead to unwanted deletion because qrform might
  //     be selected in other parts of the webpage; it's too general
  // Save state as replying onsubmit to prepare for draft discarding
  $(qrform).bind("submit", function(e) {
    localStorage.reply = true
  })

  // Add closing button to Quick Reply
  $("#fast-reply").prepend(cb)

  // TODO TODO TODO check for errors
  // Successful reply; discard draft
  if (localStorage.reply) {
    draftWrite(tid, null)
    delete localStorage.reply
  }

  // Open Quick Reply on load if a draft exists
  if (draftRead(tid)) parnt.classList.add("show-bottom")

  console.log("Loading draft " + tid)
  // Add saved draft to textarea if applicable
  texte.value = draftRead(tid, texte.value)

  makePreview()

  // Pretty-print code tags
  $("code").each(function(c) {
    c.classList.add("prettyprint")
  })
}

main()

</script>

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=sunburst"></script>
