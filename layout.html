<script>

var qsa = Document.prototype.querySelectorAll.bind(document)

function views(vs) {
    var fs = ["", "k", "m", "b"]

    function viewFormat(s) {
        var ss = s.split("<br>")
        var cs = ss[0].split(/,/g)
        var v = cs[0].trim() + fs[cs.length - 1]
        var w = ss[1] ? "\n\uf007 " + ss[1].split(' ')[0] : ""

        return v + w
    }

    for (var i = 0, l = vs.length; i < l; i++) {
        vs[i].dataset.desc = vs[i].innerHTML.split("<br>")[0].trim()
        vs[i].textContent = viewFormat(vs[i].innerHTML)
    }
}

function tf() {
    time += 100

    var vs = qsa(".c_cat-replies > a, .c_cat-views")
    if (vs.length > 0) views(vs)
    else if (time < maxTime)
        tu = setTimeout(tf, 100)
}

// this is super dumb but let's pretend it's not
var maxTime = 1000
var time = 0
var tu = setTimeout(tf, 100)

</script>

<div id="realtop">
<!-- HEADER -->
<input id="toggle-topmenu" type="checkbox">
<label for="toggle-topmenu"><div></div></label>
<!-- TOPMENU -->
</div>

<script>

var ns = qsa( "#menu_rcp > a > strong > small"
           + ", #menu_pm > a > strong > small")
  , topBar = qsa("#top_bar")[0]

for (var i = 0, l = ns.length; i < l; i++)
    if (parseInt(ns[i].textContent) > 0)
        topBar.classList.add("glow")

</script>

<div id="subhuman">
<!-- NAV -->
<input id="toggle-submenu" type="checkbox">
<label for="toggle-submenu"><div></div></label>
<!-- SUBMENU -->
</div>

<div id="wrap">
<!-- BOARD -->
</div>

<style>
.c_post > blockquote > div > blockquote > div { display: none }
.c_post > blockquote > div > blockquote > dl { cursor: pointer }
</style>

<script>

// quotePyramid :: Elem -> IO ()
function quotePyramid(s) {
    var qdls = document.querySelectorAll(".c_post > blockquote > div > blockquote > dl")
    for (var i = 0, l = qdls.length; i < l; i++)
        qdls[i].addEventListener("click", toggleQuote)
}

// toggleQuote :: Event -> IO ()
function toggleQuote(e) {
    var e = this.nextElementSibling
    e.style.display = e.style.display !== "block" ? "block" : "none"
}

quotePyramid()

var pretimeout = null
var preve = null
var texte = document.querySelector("#c_post-text")

$(texte).bind("scroll input", function(e) {
  scrollEquilibrate(preve, texte)
})

$(texte).bind("input focusout", makePreview)

// makePreview :: IO ()
function makePreview() {
  if (pretimeout === null)
    pretimeout = setTimeout(function() {
      var q = document.querySelector("#txt_quote")
        , p = document.querySelector("#c_post-text")
        , t = (q ? "[quote]" + q.value + "[/quote]" : "") + p.value

      preview(t, function(data) {
        if (preve === null) {
          preve = document.createElement("div")
          preve.id = "c_post-preview"
          preve.innerHTML = data

          document.querySelector("#c_post").appendChild(preve)

        } else preve.innerHTML = data
      })

      try {
      scrollEquilibrate(preve, texte)
      } catch (e) { console.log("scrollEquilibrate " + e.toString()) }

      pretimeout = null
    }, 250)
}

// preview :: String -> (XHR -> IO ()) -> IO ()
function preview(p, f) {
  var fd = new FormData()
  fd.append("task", '5')
  fd.append("post", p)

  var x = new XMLHttpRequest()
  x.addEventListener("load", function() { f(this.responseText) })
  x.open("POST", '/' + location.pathname.split('/')[1] + "/tasks/", true)
  x.send(fd)

  return x
}

// get total height of e1's nodes, treat non-text as one line.
// the old algorithm should become much more precise
// scrollEquilibrate :: Elem -> Elem -> IO ()
function scrollEquilibrate(e0, e1) {
  var h = 0
  var holes = []
  for (var i = 0, ns = e0.childNodes, l = ns.length; i < l; i++) {
    if (ns[i].nodeType === document.TEXT_NODE) h += textHeight(ns[i])
    else {
      // check if image, object, so forth, mark current height
      // then skip those coordinates
      if (ns[i].tagName === "IMG") {
        holes.push([h, h + ns[i].clientHeight])

        var fs = parseFloat(window.getComputedStyle(ns[i]).fontSize)
        var lh = parseFloat(window.getComputedStyle(ns[i]).lineHeight)
        h += fs * ((lh - 1) / 2 + 1)

      }
    }
  }

  var offset = Math.round(Math.cos(Math.PI * e1.scrollTop / (e1.scrollHeight - e1.clientHeight)) * 5) * -1 * 7
  // TODO FIXME account for image holes and actually use `h`?
  var scroll = (e1.scrollTop + offset) * ((e0.scrollHeight - e0.clientHeight) / (e1.scrollHeight - e1.clientHeight))

  // This is a one-liner in Haskell
  var b = false
  for (var i = 0, l = holes.length; i < l; i++)
    if (holes[i][0] > scroll && holes[i][1] < scroll) {
      scroll = holes[i][1]
      break
    }

  e0.scrollTop = scroll
}

// textHeight :: TextNode -> Int
function textHeight(tn) {
  var r = document.createRange()
  r.selectNodeContents(tn)
  var rect = r.getBoundingClientRect()
  return rect.bottom - rect.top
}

makePreview()

var cs = document.getElementsByTagName("code")
for (var i = 0, l = cs.length; i < l; i++) cs[i].classList.add("prettyprint")

</script>

<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?skin=sunburst"></script>
